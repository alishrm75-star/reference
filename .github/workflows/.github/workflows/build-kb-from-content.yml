name: Build KB from content

on:
  push:
    branches: [ main ]
    paths-ignore:
      - "kb/**"
  workflow_dispatch:

concurrency:
  group: kb-from-content
  cancel-in-progress: false

jobs:
  build-kb:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Ensure folders
        run: |
          mkdir -p kb
          mkdir -p scripts

      - name: Write builder script
        shell: bash
        run: |
          cat > scripts/build-kb-from-content.mjs <<'EOF'
          import { promises as fs } from 'node:fs';
          import path from 'node:path';

          const ROOT = process.cwd();
          const PAGES_DIR = path.join(ROOT, 'reference', 'pages');
          const FLOWS_DIR = path.join(ROOT, 'reference', 'flows');
          const KB_DIR = path.join(ROOT, 'kb');

          const isHtml = (p) => p.toLowerCase().endsWith('.html');
          const isHar  = (p) => p.toLowerCase().endsWith('.har');

          async function walk(dir) {
            const out = [];
            async function rec(d) {
              let entries;
              try { entries = await fs.readdir(d, { withFileTypes: true }); }
              catch { return; }
              for (const e of entries) {
                const p = path.join(d, e.name);
                if (e.isDirectory()) await rec(p);
                else out.push(p);
              }
            }
            await rec(dir);
            return out;
          }

          async function readText(p) {
            try { return await fs.readFile(p, 'utf8'); }
            catch { return ''; }
          }

          function extractHtmlMeta(html) {
            const titleMatch = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
            const h1Match = html.match(/<h1[^>]*>([\s\S]*?)<\/h1>/i);
            const h2Match = html.match(/<h2[^>]*>([\s\S]*?)<\/h2>/i);

            const hasSidebar  = /sidebar|drawer|offcanvas/i.test(html);
            const hasCalendar = /calendar|data-date|aria-label="Calendar"/i.test(html);
            const hasSlots    = /time-slot|data-time|aria-label="time"|class="[^"]*slot/i.test(html);
            const hasSummary  = /summary|итог|итого|total/i.test(html);
            const hasError    = /error|invalid|ошибка/i.test(html);
            const hasSuccess  = /success|успеш/i.test(html);

            return {
              title: titleMatch?.[1]?.trim() || '',
              h1: h1Match?.[1]?.trim() || '',
              h2: h2Match?.[1]?.trim() || '',
              markers: { hasSidebar, hasCalendar, hasSlots, hasSummary, hasError, hasSuccess }
            };
          }

          async function extractHarEndpoints(harPath) {
            const text = await readText(harPath);
            if (!text) return [];
            let har;
            try { har = JSON.parse(text); }
            catch { return []; }
            const entries = har?.log?.entries || [];
            const out = [];
            for (const e of entries) {
              const req = e.request || {};
              const method = (req.method || '').toUpperCase();
              const url = req.url || '';
              if (!method || !url) continue;
              if (/\.(png|jpg|jpeg|gif|svg|css|js|woff2?|map|ico)(\?|$)/i.test(url)) continue;
              if (/^data:/i.test(url)) continue;
              out.push({ method, url });
            }
            const uniq = new Map();
            for (const r of out) {
              const key = `${r.method} ${r.url}`;
              if (!uniq.has(key)) uniq.set(key, r);
            }
            return [...uniq.values()];
          }

          function niceRel(p) {
            return p.replace(process.cwd() + path.sep, '').replace(/\\/g, '/');
          }

          function inferGroupByContent(meta, rel) {
            const text = (meta.title + ' ' + meta.h1 + ' ' + meta.h2).toLowerCase();
            if (meta.markers.hasCalendar || meta.markers.hasSlots) return 'select-time';
            if (/подтверж|confirm/i.test(text)) return 'confirm';
            if (meta.markers.hasSuccess) return 'success';
            if (/услуг|service/i.test(text) || meta.markers.hasSummary) return 'select-services';
            if (/мастер|специалист|master/i.test(text)) return 'select-master';
            if (/personal|кабинет|личный/i.test(text)) return 'personal';
            if (/auth|verify|код|вход/i.test(text)) return 'auth';
            return 'misc';
          }

          function inferStateByContent(meta) {
            if (meta.markers.hasError) return 'error';
            if (meta.markers.hasSuccess) return 'success';
            if (meta.markers.hasSidebar) return 'sidebar-open';
            if (meta.markers.hasCalendar && !meta.markers.hasSlots) return 'calendar-only';
            if (meta.markers.hasCalendar && meta.markers.hasSlots) return 'calendar-with-slots';
            if (meta.markers.hasSummary) return 'summary';
            return 'base';
          }

          async function main() {
            await fs.mkdir(KB_DIR, { recursive: true });

            const pageFiles = (await walk(PAGES_DIR)).filter(isHtml);
            const pageRows = [];
            for (const abs of pageFiles) {
              const html = await readText(abs);
              const meta = extractHtmlMeta(html);
              const group = inferGroupByContent(meta, abs);
              const state = inferStateByContent(meta);
              pageRows.push({
                file: niceRel(abs),
                group, state,
                title: meta.title || meta.h1 || meta.h2 || ''
              });
            }

            const flowFiles = (await walk(FLOWS_DIR)).filter(isHar);
            const harMap = new Map();
            for (const abs of flowFiles) {
              const rel = niceRel(abs);
              const eps = await extractHarEndpoints(abs);
              for (const ep of eps) {
                const key = `${ep.method} ${ep.url}`;
                if (!harMap.has(key)) harMap.set(key, { ...ep, where: [] });
                harMap.get(key).where.push(rel);
              }
            }

            const groups = {};
            for (const r of pageRows) {
              if (!groups[r.group]) groups[r.group] = [];
              groups[r.group].push(r);
            }
            for (const g of Object.keys(groups)) {
              groups[g].sort((a,b)=>a.file.localeCompare(b.file));
            }

            let statesMd = `# States Index — построено по СОДЕРЖИМОМУ HTML\n\n`;
            statesMd += `> Источник: \`reference/pages/**\` (парсинг <title>, h1/h2 и маркеров: sidebar/calendar/slots/summary/error/success). Ориентируемся на КОНТЕНТ, не на имена.\n\n`;
            for (const [g, rows] of Object.entries(groups)) {
              statesMd += `## ${g}\n\n`;
              statesMd += `| Файл | Заголовок | Состояние |\n|------|-----------|-----------|\n`;
              for (const r of rows) {
                statesMd += `| \`${r.file}\` | ${r.title || '—'} | \`${r.state}\` |\n`;
              }
              statesMd += `\n`;
            }
            await fs.writeFile(path.join(KB_DIR, 'states-index.md'), statesMd, 'utf8');

            const endpoints = [...harMap.values()].sort((a,b)=>{
              if (a.url===b.url) return a.method.localeCompare(b.method);
              return a.url.localeCompare(b.url);
            });

            let apiMd = `# API Contracts (извлечено из HAR, без догадок)\n\n`;
            apiMd += `> Источник: \`reference/flows/**.har\`\n\n`;
            for (const e of endpoints) {
              apiMd += `### ${e.method} ${e.url}\n`;
              apiMd += `Встречается в:\n`;
              for (const w of e.where) apiMd += `- \`${w}\`\n`;
              apiMd += `\n`;
            }
            await fs.writeFile(path.join(KB_DIR, 'api-contracts.md'), apiMd, 'utf8');

            console.log(`Wrote kb/states-index.md and kb/api-contracts.md from repository CONTENT.`);
          }

          await main().catch((e)=>{ console.error(e); process.exit(1); });
          EOF

      - name: Build KB from content
        run: node scripts/build-kb-from-content.mjs

      - name: Commit KB
        run: |
          git config user.name "kb-bot"
          git config user.email "kb-bot@users.noreply.github.com"
          git add kb/states-index.md kb/api-contracts.md || true
          git commit -m "chore(kb): rebuild from content (content-based)" || echo "nothing to commit"
          git push || true
